import os
import cv2
import numpy as np
from pydicom import dicomio as dicom
import matplotlib.pyplot as plt
from skimage import measure, morphology
from mpl_toolkits.mplot3d.art3d import Poly3DCollection


def load_dicom(path):
    """
    load dicom sequence of one person to slices
    :param path: path of dicom folder
    :return: dicom slices in ascending order
    """
    slices = [dicom.read_file(os.path.join(path, x)) for x in os.listdir(path)]
    slices.sort(key= lambda x: int(x.InstanceNumber))

    if len(slices) == 0:
        print 'there is no file in path'
        return

    if hasattr(slices[0], 'SliceLocation'):
        slice_thickness = np.abs(slices[0].SliceLocation - slices[1].SliceLocation)
    elif hasattr(slices[0], 'ImagePositionPatient'):
        slice_thickness = np.abs(slices[0].ImagePositionPatient[2] - slices[1].ImagePositionPatient[2])

    for ds in slices:
        ds.SliceThickness = slice_thickness

    return slices


def get_pixel_HU(dicom_scans):
    image = np.stack(ds.pixel_array for ds in dicom_scans)
    image = image.astype(np.int16)

    image[image == -2000] = 0
    intercept = dicom_scans[0].RescaleIntercept
    slope = dicom_scans[0].RescaleSlope

    if slope != 1:
        image = slope*image.astype(np.float64)
        image = image.astype(np.int16)

    image += np.int16(intercept)

    return np.array(image, dtype=np.int16)


def get_pixel_HU_with_window(dicom_scans, window_width, window_level):
    """
    convert the pixel value of dicom into 0-255 based on given w-w and w-l.
    sequence to sequence conversion
    :param dicom_scans: dicom sequence
    :param window_width:
    :param window_level:
    :return: dicom image sequence in ndarray
    """
    image = np.stack(ds.pixel_array for ds in dicom_scans)
    image = image.astype(np.int16)

    w_min = int(window_level - window_width/2.0)
    w_max = int(window_level + window_width/2.0)

    image_cut = np.zeros(image.shape) + 1*(image<w_min) + 2*(image>w_max)
    res_image = (image-w_min)*1.0/window_width*255
    res_image[image_cut == 1] = 0
    res_image[image_cut == 2] = 255

    return np.array(res_image, dtype=np.int16)


def dicom2gray(dicom_scan, window_width, window_level):
    """
    convert dicom into 0-255, single image conversion
    :param dicom_scan: dicom file
    :param window_width:
    :param window_level:
    :return:
    """
    ds = dicom_scan.pixel_array

    w_min = int(window_level - window_width / 2.0)
    w_max = int(window_level + window_width / 2.0)

    image_cut = np.zeros(ds.shape) + 1*(ds<w_min) + 2*(ds>w_max)
    res_image = (ds-w_min)*1.0/window_width*255
    res_image[image_cut == 1] = 0
    res_image[image_cut == 2] = 255

    return np.array(res_image, dtype=np.int16)


def dicom_sequence_is_forward(seq_head_np, seq_tail_np, pixel_thres=50, rate=0.2):
    """
    check if the sequence is from shoulder to stomach or backward
    :param seq_head: the first image in sequence
    :param seq_tail: the end image in sequence
    :param pixel_thres: threshold for binarization
    :param rate: threshold rate for determining whether an imgae is generated by wrong ww&wl
    :return: -1 - error image, 0-forward, 1-backward
    """

    if np.sum(seq_head_np>pixel_thres) < seq_head_np.shape[0]*seq_head_np.shape[1]*rate:
        return -1

    if np.sum(seq_head_np == 255) > seq_head_np.shape[0]*seq_head_np.shape[1]*rate:
        return -1

    if np.sum(seq_head_np>pixel_thres) > np.sum(seq_tail_np>pixel_thres):
        return 1
    else:
        return 0


def revert_sequence(person, root_folder, reversed_folder):
    if not os.path.exists(os.path.join(reversed_folder, person)):
        os.system('mkdir {}'.format(os.path.join(reversed_folder, person)))

    person_path = os.path.join(root_folder, person)

    total_num = len(os.listdir(person_path))

    for dicom_file in os.listdir(person_path):
        ds = dicom.read_file(os.path.join(person_path, dicom_file))
        ds.InstanceNumber = total_num - 1 - ds.InstanceNumber
        dicom.write_file(os.path.join(reversed_folder, person, dicom_file), ds)


